// Shippy - Prisma Schema
// Database: PostgreSQL

generator client {
  provider   = "prisma-client-js"
  engineType = "client"
}

datasource db {
  provider = "postgresql"
}

// ================================
// Better Auth Models
// ================================

model User {
  id            String    @id @default(dbgenerated("nanoid()"))
  name          String
  email         String    @unique
  username      String?   @unique // URL-friendly slug (e.g., "iwasrobbed")
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt     DateTime  @updatedAt @db.Timestamptz(3)
  sessions      Session[]
  accounts      Account[]

  // Shippy relations
  ownedProjects       Project[]
  bountyClaims        BountyClaim[]
  submissions         Submission[]
  submissionEvents    SubmissionEvent[]
  payoutRecipients    PayoutRecipient[]
  bountyEvents        BountyEvent[]
  suggestedBounties   Bounty[]             @relation("SuggestedBounties")
  notifications       Notification[]       @relation("NotificationRecipient")
  actedNotifications  Notification[]       @relation("NotificationActor")
  threadSubscriptions ThreadSubscription[]
  mcpAccessTokens     McpAccessToken[]
  attachments         Attachment[]

  @@index([username])
  @@map("user")
}

model Session {
  id        String   @id @default(dbgenerated("nanoid()"))
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime @db.Timestamptz(3)
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @default(dbgenerated("nanoid()"))
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime? @db.Timestamptz(3)
  refreshTokenExpiresAt DateTime? @db.Timestamptz(3)
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt             DateTime  @updatedAt @db.Timestamptz(3)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @default(dbgenerated("nanoid()"))
  identifier String
  value      String
  expiresAt  DateTime @db.Timestamptz(3)
  createdAt  DateTime @default(now()) @db.Timestamptz(3)
  updatedAt  DateTime @updatedAt @db.Timestamptz(3)

  @@map("verification")
}

// ================================
// Shippy - Core Models
// ================================

/// A project is a startup/product that can have bounties and contributors
model Project {
  id          String   @id @default(dbgenerated("nanoid()"))
  slug        String   @unique // URL-friendly identifier
  name        String
  /// 3-letter project key used in bounty identifiers (e.g., "OTH" -> "OTH-32")
  /// Must be unique per founder across their projects.
  projectKey  String   @db.VarChar(3)
  tagline     String? // Short description
  description String?  @db.Text // Markdown readme content
  logoUrl     String?
  websiteUrl  String?
  discordUrl  String?
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime @updatedAt @db.Timestamptz(3)

  // Payout visibility: "PRIVATE" = only show confirmation status, "PUBLIC" = show $ amounts
  payoutVisibility String @default("PRIVATE")

  // Founder/Owner
  founderId String
  founder   User   @relation(fields: [founderId], references: [id], onDelete: Cascade)

  // Sequence for assigning per-project bounty numbers (for display IDs like KEY-123)
  nextBountyNumber Int @default(1)

  // Relations
  rewardPool       RewardPool?
  bounties         Bounty[]
  payouts          Payout[]
  labels           Label[]
  githubConnection GitHubConnection?

  @@index([founderId])
  @@index([isPublic])
  @@unique([founderId, projectKey])
  @@map("project")
}

/// The reward pool defines how much profit/revenue is shared with contributors
model RewardPool {
  id        String   @id @default(dbgenerated("nanoid()"))
  projectId String   @unique
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // Pool configuration
  poolPercentage   Int // Percentage of profit/revenue (e.g., 10 = 10%)
  poolCapacity     Int      @default(1000) // Total points representing 100% of pool (1 pt = 0.1%)
  payoutFrequency  String // "MONTHLY" | "QUARTERLY" - stored as string, typed via TS
  profitBasis      String   @default("NET_PROFIT") // "NET_PROFIT" | "GROSS_REVENUE"
  commitmentMonths Int      @default(12) // Commitment period in months
  commitmentEndsAt DateTime @db.Timestamptz(3) // When the pool commitment ends

  // Platform fee (percentage of pool that goes to Shippy)
  platformFeePercentage Int @default(10) // 10% of the pool

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  expansionEvents PoolExpansionEvent[]

  @@map("reward_pool")
}

/// Tracks pool capacity expansions for transparency
model PoolExpansionEvent {
  id           String     @id @default(dbgenerated("nanoid()"))
  rewardPoolId String
  rewardPool   RewardPool @relation(fields: [rewardPoolId], references: [id], onDelete: Cascade)

  // Expansion details
  previousCapacity Int // Capacity before expansion
  newCapacity      Int // Capacity after expansion
  reason           String  @db.Text // Founder-provided reason for expansion
  dilutionPercent  Decimal @db.Decimal(5, 2) // Calculated dilution (e.g., 16.7%)

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([rewardPoolId])
  @@map("pool_expansion_event")
}

/// Custom labels for bounties (per-project, like Linear)
model Label {
  id        String  @id @default(dbgenerated("nanoid()"))
  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  name  String // Display name (e.g., "Growth", "Bug Fix")
  color String // Color key: "grey" | "dark_grey" | "purple" | "teal" | "green" | "yellow" | "orange" | "pink" | "red"

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  bounties BountyLabel[]

  @@unique([projectId, name]) // Label names must be unique per project
  @@index([projectId])
  @@map("label")
}

/// A bounty is a specific task with point rewards
model Bounty {
  id        String  @id @default(dbgenerated("nanoid()"))
  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // Bounty details
  /// Per-project sequential number used in display IDs (e.g., "OTH-32")
  number      Int
  title       String
  description String @db.Text // What's required, how success is verified
  points      Int? // Point reward for completing this bounty (null = backlog/suggested, not yet estimated)
  status      String @default("OPEN") // "SUGGESTED" | "BACKLOG" | "OPEN" | "CLAIMED" | "COMPLETED" | "CLOSED"

  // Suggested bounty tracking (when a contributor suggests a bounty for founder review)
  suggestedById String? // User who suggested the bounty (null = created by founder)
  suggestedBy   User?   @relation("SuggestedBounties", fields: [suggestedById], references: [id], onDelete: SetNull)

  // Claim configuration
  claimMode       String   @default("SINGLE") // "SINGLE" (Exclusive) | "COMPETITIVE" (First wins) | "MULTIPLE" (All get points) | "PERFORMANCE" (Points per result)
  claimExpiryDays Int      @default(14) // Days before a claim expires
  maxClaims       Int? // Max number of claims (null = unlimited for COMPETITIVE/MULTIPLE modes)

  // Evidence requirements
  evidenceDescription String? @db.Text // What proof is needed

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  labels          BountyLabel[]
  claims          BountyClaim[]
  submissions     Submission[]
  events          BountyEvent[]
  githubIssueLink GitHubIssueLink?

  @@index([projectId])
  @@index([status])
  @@index([suggestedById])
  @@unique([projectId, number])
  @@map("bounty")
}

/// Join table for bounty-label many-to-many relationship
model BountyLabel {
  id       String @id @default(dbgenerated("nanoid()"))
  bountyId String
  bounty   Bounty @relation(fields: [bountyId], references: [id], onDelete: Cascade)
  labelId  String
  label    Label  @relation(fields: [labelId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@unique([bountyId, labelId])
  @@index([bountyId])
  @@index([labelId])
  @@map("bounty_label")
}

/// Timeline events for bounties (comments, edits, status changes - like Linear's activity feed)
model BountyEvent {
  id       String @id @default(dbgenerated("nanoid()"))
  bountyId String
  bounty   Bounty @relation(fields: [bountyId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Event type: "COMMENT" | "EDIT" | "STATUS_CHANGE"
  type String

  // For COMMENT events
  content String? @db.Text

  // For EDIT events - structured changes { field: { from: oldValue, to: newValue } }
  changes Json?

  // For STATUS_CHANGE events
  fromStatus String?
  toStatus   String?
  note       String? @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([bountyId])
  @@index([userId])
  @@map("bounty_event")
}

/// A claim represents a contributor's intent to work on a bounty
model BountyClaim {
  id       String @id @default(dbgenerated("nanoid()"))
  bountyId String
  bounty   Bounty @relation(fields: [bountyId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  status    String   @default("ACTIVE") // "ACTIVE" | "EXPIRED" | "RELEASED" | "SUBMITTED" | "COMPLETED"
  expiresAt DateTime @db.Timestamptz(3) // When this claim expires if no submission
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@index([bountyId])
  @@index([userId])
  @@index([status])
  @@map("bounty_claim")
}

/// A submission is work + proof submitted by a contributor for a bounty
model Submission {
  id       String @id @default(dbgenerated("nanoid()"))
  bountyId String
  bounty   Bounty @relation(fields: [bountyId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Submission content
  description String @db.Text // What was done, context, notes
  status      String @default("PENDING") // "DRAFT" | "PENDING" | "NEEDS_INFO" | "APPROVED" | "REJECTED"

  // Points awarded (only set when approved)
  pointsAwarded Int?
  approvedAt    DateTime? @db.Timestamptz(3)
  rejectedAt    DateTime? @db.Timestamptz(3)
  rejectionNote String?   @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  events       SubmissionEvent[]
  githubPRLink GitHubPRLink?

  @@index([bountyId])
  @@index([userId])
  @@index([status])
  @@map("submission")
}

/// Timeline events for submissions (comments, edits, status changes - like GitHub PR activity)
model SubmissionEvent {
  id           String     @id @default(dbgenerated("nanoid()"))
  submissionId String
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Event type: "COMMENT" | "EDIT" | "STATUS_CHANGE"
  type String

  // For COMMENT events
  content String? @db.Text

  // For EDIT events - structured changes { field: { from: oldValue, to: newValue } }
  changes Json?

  // For STATUS_CHANGE events
  fromStatus String? // Previous status (null for initial submission)
  toStatus   String? // New status
  note       String? @db.Text // Optional note accompanying status change (e.g., rejection reason)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@index([submissionId])
  @@index([userId])
  @@map("submission_event")
}

/// Generic file attachments (stored in R2) - used for bounties, submissions, comments, etc.
model Attachment {
  id String @id @default(dbgenerated("nanoid()"))

  // Polymorphic reference (like Notification)
  referenceType String // "BOUNTY" | "SUBMISSION" | "BOUNTY_COMMENT" | "SUBMISSION_COMMENT"
  referenceId   String // ID of the bounty/submission/event

  // Uploader
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // File metadata
  fileName    String
  fileUrl     String // R2 public URL
  fileKey     String // R2 object key (for deletion)
  fileSize    Int // Size in bytes
  contentType String

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([referenceType, referenceId])
  @@index([userId])
  @@map("attachment")
}

// ================================
// Shippy - Payout Models
// ================================

/// A payout represents a distribution of the reward pool for a period
model Payout {
  id        String  @id @default(dbgenerated("nanoid()"))
  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // Period
  periodStart DateTime @db.Timestamptz(3)
  periodEnd   DateTime @db.Timestamptz(3)
  periodLabel String // e.g., "December 2024", "Q4 2024"

  // Financials (all in cents to avoid floating point issues)
  // Using BigInt for cents to support amounts up to ~$92 quadrillion
  reportedProfitCents  BigInt // Profit/revenue reported by founder
  poolAmountCents      BigInt // Pool amount (profit * pool %)
  platformFeeCents     BigInt // Platform fee (pool * platform %)
  totalPointsAtPayout  Int // Total earned points at time of payout (for calculating shares)
  poolCapacityAtPayout Int // Pool capacity at time of payout (for calculating utilization)

  // Status
  status   String   @default("ANNOUNCED") // "ANNOUNCED" | "SENT" | "COMPLETED"
  sentAt   DateTime? @db.Timestamptz(3) // When founder marked as sent
  sentNote String? // Optional payment reference

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  // Relations
  recipients PayoutRecipient[]

  @@index([projectId])
  @@index([status])
  @@map("payout")
}

/// Individual contributor's share of a payout
model PayoutRecipient {
  id       String @id @default(dbgenerated("nanoid()"))
  payoutId String
  payout   Payout @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Share calculation
  pointsAtPayout Int // Points this user had at payout time
  sharePercent   Decimal  @db.Decimal(5, 2) // Percentage of pool (e.g., 25.50)
  amountCents    BigInt // Amount in cents (BigInt to handle large payouts)

  // Payment tracking (founder marks as paid)
  paidAt   DateTime? @db.Timestamptz(3) // When founder marked this recipient as paid
  paidNote String? // Optional payment reference (e.g., "PayPal txn #12345")

  // Confirmation (contributor confirms receipt)
  status        String   @default("PENDING") // "PENDING" | "CONFIRMED" | "DISPUTED" | "UNCONFIRMED"
  confirmedAt   DateTime? @db.Timestamptz(3)
  disputedAt    DateTime? @db.Timestamptz(3)
  confirmNote   String? // Optional note from contributor
  disputeReason String?   @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@unique([payoutId, userId]) // One recipient per user per payout
  @@index([payoutId])
  @@index([userId])
  @@index([status])
  @@map("payout_recipient")
}

// ================================
// Notifications
// ================================

/// A notification for a user about activity relevant to them
model Notification {
  id     String @id @default(dbgenerated("nanoid()"))
  userId String
  user   User   @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)

  // Notification type (extensible for future notification kinds)
  type String // NotificationType enum: "BOUNTY_COMMENT" | "SUBMISSION_COMMENT" | ...

  // Reference to the entity - allows grouping and navigation
  referenceType String // "BOUNTY" | "SUBMISSION"
  referenceId   String // ID of the bounty/submission

  // Who triggered this notification
  actorId String
  actor   User   @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)

  // Read state
  readAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([userId, readAt]) // Fetch unread for a user
  @@index([userId, createdAt]) // Fetch recent for a user
  @@index([referenceType, referenceId]) // Group by entity
  @@map("notification")
}

/// Tracks user preferences for specific threads (mute/watch)
model ThreadSubscription {
  id     String @id @default(dbgenerated("nanoid()"))
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  referenceType String // "BOUNTY" | "SUBMISSION" | "PROJECT"
  referenceId   String

  // Subscription state (only muted used in MVP)
  muted    Boolean @default(false) // Explicitly opted out
  watching Boolean @default(false) // Explicitly opted in (future)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@unique([userId, referenceType, referenceId])
  @@index([userId])
  @@map("thread_subscription")
}

// ================================
// GitHub App Integration
// ================================

/// Links a Shippy project to a GitHub repository via the GitHub App
model GitHubConnection {
  id        String  @id @default(dbgenerated("nanoid()"))
  projectId String  @unique
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // GitHub identifiers
  installationId Int    // GitHub App installation ID
  repoId         Int    // GitHub repository ID
  repoFullName   String // e.g., "shippy-sh/shippy"

  // Settings
  autoApproveOnMerge Boolean @default(false) // Auto-approve submissions when linked PR merges

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@index([installationId])
  @@index([repoId])
  @@map("github_connection")
}

/// Links a Shippy bounty to a GitHub issue (created via /bounty command)
model GitHubIssueLink {
  id       String @id @default(dbgenerated("nanoid()"))
  bountyId String @unique
  bounty   Bounty @relation(fields: [bountyId], references: [id], onDelete: Cascade)

  // GitHub issue identifiers
  repoId      Int    // GitHub repository ID
  issueNumber Int    // Issue number in the repo
  issueNodeId String // GitHub's global node ID for the issue

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@unique([repoId, issueNumber]) // One bounty per repo+issue
  @@index([repoId])
  @@map("github_issue_link")
}

/// Links a Shippy submission to a GitHub PR (for auto-approval tracking)
model GitHubPRLink {
  id           String     @id @default(dbgenerated("nanoid()"))
  submissionId String     @unique
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  // GitHub PR identifiers
  repoId     Int       // GitHub repository ID
  prNumber   Int       // PR number in the repo
  prNodeId   String    // GitHub's global node ID for the PR
  prUrl      String    // Full URL to the PR
  prMergedAt DateTime? @db.Timestamptz(3) // When the PR was merged (null if not merged)

  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @db.Timestamptz(3)

  @@index([repoId])
  @@map("github_pr_link")
}

// ================================
// MCP Access Tokens
// ================================

/// Personal access tokens for MCP (Model Context Protocol) clients like Cursor
model McpAccessToken {
  id     String @id @default(dbgenerated("nanoid()"))
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Token details (stored hashed, prefixed with "shp_" in raw form)
  tokenHash String @unique // SHA-256 hash of the token
  name      String // User-provided label (e.g., "Cursor on MacBook")

  // Usage tracking
  lastUsedAt DateTime? @db.Timestamptz(3)

  // Optional expiration
  expiresAt DateTime? @db.Timestamptz(3)

  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([userId])
  @@map("mcp_access_token")
}
